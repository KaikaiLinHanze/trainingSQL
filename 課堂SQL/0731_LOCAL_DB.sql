-- 語法所帶來的　"功能效果"
SELECT * FROM STORE_INFORMATION
ORDER BY SALES DESC;

-- 營業額最高的商店
SELECT * FROM STORE_INFORMATION
WHERE SALES = 3000;

SELECT MAX(SALES) FROM STORE_INFORMATION;

-- 子查詢
SELECT * FROM STORE_INFORMATION
WHERE SALES = (
	SELECT MAX(SALES) FROM STORE_INFORMATION
);

-- 子查詢可視為「暫存表」的觀念
SELECT G.*, S.* 
FROM(
	SELECT * FROM STORE_INFORMATION
)S,(
  SELECT * FROM GEOGRAPHY
)G 
WHERE S.GEOGRAPHY_ID = G.GEOGRAPHY_ID;

-- CTE(Common Table Expressions)
WITH S AS (
	SELECT * FROM STORE_INFORMATION
),
G AS (
	SELECT * FROM GEOGRAPHY
)
SELECT G.*, S.* 
FROM S,G
WHERE S.GEOGRAPHY_ID = G.GEOGRAPHY_ID;



SELECT G.*, S.* FROM (
   SELECT GEOGRAPHY_ID, REGION_NAME FROM GEOGRAPHY
) G , 
(
   SELECT STORE.GEOGRAPHY_ID, STORE.STORE_NAME
   FROM STORE_INFORMATION STORE, G
   WHERE G.GEOGRAPHY_ID = STORE.GEOGRAPHY_ID
) S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;



WITH G AS (
  SELECT GEOGRAPHY_ID, REGION_NAME FROM GEOGRAPHY
) ,
S AS (
  SELECT G.GEOGRAPHY_ID, G.REGION_NAME, STORE.STORE_NAME 
  FROM STORE_INFORMATION STORE, G
  WHERE G.GEOGRAPHY_ID = STORE.GEOGRAPHY_ID
)
SELECT S.*  FROM S;
--  WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;



-- HR DB 資料查詢
-- 查詢每個部門高於平均部門薪資的員工
-- (結果依部門平均薪資降冪排序)

-- STEP1:算出每個部門的「平均部門薪資」
SELECT DEPARTMENT_ID, TRUNCATE(AVG(SALARY), 0) DEP_AVG_SALARY
FROM EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- 找出所有大於「平均部門薪資」的員工
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, 
	D.DEPARTMENT_NAME,
	AVG_DEP.DEPARTMENT_ID, AVG_DEP.DEP_AVG_SALARY
FROM (
	SELECT DEPARTMENT_ID, TRUNCATE(AVG(SALARY), 0) DEP_AVG_SALARY
	FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID
) AVG_DEP, EMPLOYEES E, DEPARTMENTS D
WHERE AVG_DEP.DEPARTMENT_ID = E.DEPARTMENT_ID
AND D.DEPARTMENT_ID = E.DEPARTMENT_ID
AND E.SALARY > AVG_DEP.DEP_AVG_SALARY
ORDER BY AVG_DEP.DEP_AVG_SALARY DESC;

-- MySQL
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, 
	D.DEPARTMENT_NAME,
	AVG_DEP.DEPARTMENT_ID, AVG_DEP.DEP_AVG_SALARY
FROM (
	SELECT DEPARTMENT_ID, TRUNCATE(AVG(SALARY), 0) DEP_AVG_SALARY
	FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID
) AVG_DEP JOIN EMPLOYEES E ON AVG_DEP.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE E.SALARY > AVG_DEP.DEP_AVG_SALARY
ORDER BY AVG_DEP.DEP_AVG_SALARY DESC;

-- Oracle、MySQL
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, 
	D.DEPARTMENT_NAME,
	AVG_DEP.DEPARTMENT_ID, AVG_DEP.DEP_AVG_SALARY
FROM (
	SELECT DEPARTMENT_ID, FLOOR(AVG(SALARY)) DEP_AVG_SALARY
	FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID
) AVG_DEP JOIN EMPLOYEES E ON AVG_DEP.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE E.SALARY > AVG_DEP.DEP_AVG_SALARY
ORDER BY AVG_DEP.DEP_AVG_SALARY DESC;


WITH AVG_DEP AS (
	SELECT DEPARTMENT_ID, FLOOR(AVG(SALARY)) DEP_AVG_SALARY
	FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID
)
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, 
	D.DEPARTMENT_NAME,
	AVG_DEP.DEPARTMENT_ID, AVG_DEP.DEP_AVG_SALARY
FROM AVG_DEP JOIN EMPLOYEES E ON AVG_DEP.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE E.SALARY > AVG_DEP.DEP_AVG_SALARY
ORDER BY AVG_DEP.DEP_AVG_SALARY DESC;


-- CTE的精神在於「分段」查詢
-- "下面"的子查詢可以使用"上面"子查詢的資料結果
-- 以達到層層條件過濾的資料查詢手法!
WITH AVG_DEP AS (
	-- 階段1.平均部門薪資
	SELECT DEPARTMENT_ID, FLOOR(AVG(SALARY)) DEP_AVG_SALARY
	FROM EMPLOYEES
	GROUP BY DEPARTMENT_ID
),
E AS (
	-- 階段2.找出大於"階段1.平均部門薪資"的員工
	SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, 		
		AVG_DEP.DEPARTMENT_ID, AVG_DEP.DEP_AVG_SALARY
	FROM AVG_DEP JOIN EMPLOYEES E ON AVG_DEP.DEPARTMENT_ID = E.DEPARTMENT_ID
    WHERE E.SALARY > AVG_DEP.DEP_AVG_SALARY
)
-- 階段3.最終找出大於"平均部門薪資"的員工與部門名稱
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, 
	D.DEPARTMENT_NAME,
	AVG_DEP.DEPARTMENT_ID, AVG_DEP.DEP_AVG_SALARY
FROM E JOIN DEPARTMENTS D ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN AVG_DEP ON AVG_DEP.DEPARTMENT_ID = E.DEPARTMENT_ID
ORDER BY AVG_DEP.DEP_AVG_SALARY DESC;


SELECT S.*, YEAR(S.STORE_DATE), MONTH(S.STORE_DATE),
	CONCAT(YEAR(S.STORE_DATE), MONTH(S.STORE_DATE))
FROM STORE_INFORMATION S
WHERE YEAR(S.STORE_DATE) = '2018' 
AND MONTH(S.STORE_DATE) = '2';


-- MySQL
SELECT SYSDATE(), YEAR(SYSDATE()), YEAR(SYSDATE()) - 1911 "民國",
MONTH(SYSDATE()), DAY(SYSDATE()),
HOUR(SYSDATE()), MINUTE(SYSDATE()), SECOND(SYSDATE());


-- Oracle
SELECT S.*, TRUNC(S.STORE_DATE, 'YEAR'), TRUNC(S.STORE_DATE, 'MONTH')
FROM STORE_INFORMATION S;

-- Oracle
SELECT S.*, TRUNC(S.STORE_DATE, 'MONTH')
FROM STORE_INFORMATION S
WHERE TRUNC(S.STORE_DATE, 'MONTH') = '2018-02-01';



--  MySQL日期算術:
-- 	DATE_SUB()語法(Syntax)：DATE_SUB(datetime,INTERVAL expr UNIT)
-- 	expr 用來指定你要減去的時間間隔，UNIT 是 expr 的單位。
-- 	常用的 unit 單位有：
-- 	MINUTE、HOUR、DAY、WEEK、MONTH、YEAR
SELECT SYSDATE(), 
DATE_ADD('2021-08-15', INTERVAL 1 DAY),
DATE_ADD('2021-08-15', INTERVAL 1 MINUTE),
DATE_ADD('2021-08-01', INTERVAL 1 WEEK);

--  Oracle日期算術:
-- 1.d1–d2：返回d1和d2之間相差的天數
SELECT  (TO_DATE('2018/05/15','YYYY-mm-DD') - TO_DATE('2018/05/01','YYYY-mm-DD'))  DIFF_DAY,
-- 2.d1+ n ：在d1上加上n天并作為date類型返回結果
(TO_DATE('2018/05/01','YYYY-mm-DD') +  14)  ADD_DAY,
-- 3.D1–N ：從D1上減去N天并作為DATE類型返回結果(兩個日期不能相加)
(TO_DATE('2018/05/15','YYYY-mm-DD') -  14)  SUBTRACT_DAY
FROM DUAL;


-- MySQL轉換函數：
-- 1.DATE_FORMAT(date,format):日期轉字串
SELECT DATE_FORMAT(SYSDATE(), '%m-%d-%Y %T'),
-- 2.STR_TO_DATE(str,format):字串轉日期
STR_TO_DATE('2021-08-15', "%Y-%m-%d"),
DATE_ADD(STR_TO_DATE('2021-08-15 00:00:00', "%Y-%m-%d %T"), INTERVAL 5 DAY);


SELECT STORE_DATE, DATE_FORMAT(STORE_DATE, '%m-%d-%Y %T')
FROM store_information;

-- Oracle
-- 1.TO_CHAR(d , format)：日期轉字串
SELECT TO_CHAR(sysdate,'mm-DD-YYYY HH24:MI:SS'),
  -- 2.TO_DATE(string ,format)：字串轉日期
  TO_DATE('2018-05-15 21:30:23','YYYY-mm-DD HH24:MI:SS'),
  -- 3.TO_TIMESTAMP(string,  [format])：字串轉日期
  TO_TIMESTAMP( '2011-12-23 12:30:23.999', 'YYYY-MM-DD HH24:MI:SS.FF3'),
  -- 4.TO_NUMBER(STRING)：字串轉數字
  TO_NUMBER('3') + TO_NUMBER('2')
FROM DUAL;


SELECT CONVERT('150', UNSIGNED INTEGER) + 5;

SELECT '155' + 5;

SELECT * FROM store_information;

-- 資料新增
INSERT INTO STORE_INFORMATION (STORE_ID,STORE_NAME,SALES,STORE_DATE, GEOGRAPHY_ID) 
VALUES (10,'Apple Inc', 5500, STR_TO_DATE('2018-08-15', "%Y-%m-%d"), 3);

-- 資料更新
-- UPDATE "表格名"SET "欄位1" = [新值]WHERE {條件} 
UPDATE STORE_INFORMATION SET SALES = 6600, STORE_NAME = 'appple inc' WHERE STORE_ID = 10;

-- 資料刪除
-- DELETE FROM "表格名"WHERE {條件} 
DELETE FROM STORE_INFORMATION WHERE STORE_ID = 10;

-- 資料提交
COMMIT;

-- 資料回滾(交易取消)
ROLLBACK;


-- UNION 聯集(不包含重覆值)
-- 每個查詢之間"欄位個數","資料型態"必須一致!
SELECT GEOGRAPHY_ID FROM GEOGRAPHY
UNION
SELECT STORE_NAME FROM STORE_INFORMATION;

SELECT * FROM STORE_INFORMATION;

-- UNION ALL 聯集(包含重覆值)
SELECT GEOGRAPHY_ID FROM GEOGRAPHY
UNION ALL
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;


-- INTERSECT 交集
-- MySQL 目前還不支援 INTERSECT。
(SELECT GEOGRAPHY_ID FROM GEOGRAPHY)
INTERSECT
(SELECT GEOGRAPHY_ID FROM STORE_INFORMATION);


-- Minus(排除)
-- 1.A,B,C
-- 2.C,D,E
-- A,B

-- MySQL 目前還不支援 MINUS。
SELECT GEOGRAPHY_ID FROM GEOGRAPHY
MINUS
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;



-- 外查詢
SELECT SUM(Sales) FROM Store_Information
-- EXISTS(內查詢是否"存在"有結果，有結果的話就執行外查詢)
WHERE EXISTS
-- 內查詢
(SELECT * FROM Geography WHERE REGION_NAME = 'West');


-- 外查詢
SELECT SUM(Sales) FROM Store_Information
-- EXISTS(內查詢是否"非存在"有結果，有結果的話就執行外查詢)
WHERE NOT EXISTS
-- 內查詢
(SELECT * FROM Geography WHERE REGION_NAME = 'West');

-- 1.CASE 後面加欄位
SELECT STORE_NAME, SALES,
CASE STORE_NAME  
  WHEN 'Los Angeles' THEN SALES * 2  
  WHEN 'San Diego'   THEN SALES * 1.5
  ELSE SALES  END "New Sales",
  STORE_DATE
FROM STORE_INFORMATION;


-- 2.CASE 不加欄位，單單只有"條件式"
-- 計算營業額各金額區間的資料筆數
-- 0-1000 (?)
-- 1001-2000 (?)
-- 2001-3000 (?)
-- > 3000 (?)
SELECT RANGE_SALES, COUNT(RANGE_SALES) 
FROM (
	SELECT STORE_NAME, SALES,
	CASE   
	  WHEN (SALES BETWEEN 0 AND 1000) THEN '0-1000'
	  WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001-2000'
	  WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001-3000'
	  WHEN (SALES > 3000) THEN '> 3000' 
	  END "RANGE_SALES"
	FROM STORE_INFORMATION
    ORDER BY SALES
) RANGE_STORE
GROUP BY RANGE_SALES;


-- RANK( ) OVER ( [query_partition_clause ] order_by_clause)

-- 全部資料排名
SELECT S.* , 
RANK() OVER(ORDER BY SALES DESC) "STORE_RANK"
FROM STORE_INFORMATION S;

-- 分區排名
SELECT S.* , 
RANK() OVER(PARTITION BY GEOGRAPHY_ID ORDER BY SALES DESC) "STORE_RANK"
FROM STORE_INFORMATION S;


SELECT S.*,
	RANK() OVER(ORDER BY SALES DESC) "STORE_RANK",
    -- 當有同名次時(排名结果是連續的)
    DENSE_RANK() OVER(ORDER BY SALES DESC) "STORE_DENSE_RANK",
    ROW_NUMBER() OVER(ORDER BY SALES DESC) "STORE_ROW_NUMBER"
FROM STORE_INFORMATION S;


SELECT S.* FROM STORE_INFORMATION S
ORDER BY GEOGRAPHY_ID;


-- 計算每個商店的營業額，與最高營業額的差距
SELECT S.*,
	-- 依區域分別的"最高"營業額
    MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) GEOGRAPHY_MAX_SALES,
    -- 依區域分別的"最小"營業額
    MIN(SALES) OVER (PARTITION BY GEOGRAPHY_ID) GEOGRAPHY_MIN_SALES,
    -- 依區域分別"加總"
    SUM(SALES) OVER (PARTITION BY GEOGRAPHY_ID) GEOGRAPHY_SUM_SALES,
    -- 依區域分別"平均"
    AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID) GEOGRAPHY_AVG_SALES,
    -- 依區域分別"資料個數"
    COUNT(SALES) OVER (PARTITION BY GEOGRAPHY_ID) GEOGRAPHY_COUNT_SALES
FROM STORE_INFORMATION S
ORDER BY GEOGRAPHY_ID ,SALES DESC;














