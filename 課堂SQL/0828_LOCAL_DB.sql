--  一號交易員
SELECT * FROM STORE_INFORMATION;

DELETE FROM STORE_INFORMATION;

COMMIT;

INSERT INTO STORE_INFORMATION (STORE_ID,STORE_NAME,SALES,STORE_DATE,GEOGRAPHY_ID) VALUES (1,'Boston',2200,'2018-03-09 00:00:00',1);
INSERT INTO STORE_INFORMATION (STORE_ID,STORE_NAME,SALES,STORE_DATE,GEOGRAPHY_ID) VALUES (2,'Los Angeles',1400,'2018-04-05 00:00:00',2);

ROLLBACK;


-- UNION(不包含重覆值)
-- 指令的目的是將兩個 SQL 語句的結果"合併"起來
-- 1.資料結果不包含重覆值
-- 2.查詢子句之間的查欄位必須是相同"欄位類型"(MySQL除外)
-- 3.查詢子句之間的查"欄位個數"必須一樣
SELECT STORE_NAME FROM STORE_INFORMATION
UNION
SELECT REGION_NAME FROM GEOGRAPHY;


SELECT STORE_DATE FROM STORE_INFORMATION
UNION
SELECT REGION_NAME FROM GEOGRAPHY;

-- The used SELECT statements have a different number of columns
SELECT STORE_NAME, STORE_DATE FROM STORE_INFORMATION
UNION
SELECT REGION_NAME FROM GEOGRAPHY;

-- UNION ALL 聯集(包含重覆值)
SELECT REGION_NAME FROM GEOGRAPHY
UNION ALL
SELECT REGION_NAME FROM GEOGRAPHY;

-- INTERSECT 交集
-- MySQL不支援 INTERSECT 查詢
-- 1,2,null
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;
INTERSECT
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY;

-- 1.A,B,C,D
-- MINUS 
-- 2.C,D,E,F
-- A,B

-- MySQL 不支援
-- Oracle(MINUS)排除查詢
-- 執行結果:3
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY
MINUS
-- 1,2,null
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;

-- MS SQL(EXCEPT)
-- 執行結果:3
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY
EXCEPT
-- 1,2,null
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;


-- EXISTS(資料是否"有"存在查詢)
-- 13,250
-- 外查詢
SELECT SUM(Sales) FROM STORE_INFORMATION
WHERE EXISTS (
	-- 內查詢
	SELECT * FROM GEOGRAPHY WHERE REGION_NAME = 'West'
);

-- EXISTS JOIN 內外關聯查詢
-- 6,550
-- 外查詢
SELECT SUM(Sales) FROM STORE_INFORMATION S
WHERE EXISTS (
	-- 內查詢
	SELECT G.* FROM GEOGRAPHY G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
    AND G.REGION_NAME = 'West'
);


-- NOT EXISTS(資料是否"沒有"存在查詢)
-- NULL
SELECT SUM(Sales) FROM STORE_INFORMATION
WHERE NOT EXISTS (
	-- 內查詢
	SELECT * FROM GEOGRAPHY WHERE REGION_NAME = 'West'
);

-- CASE WHEN "條件式查詢"
-- CASE 有接欄位
-- 'Los Angeles' 的 Sales 數值乘以2
-- 'San Diego' 的 Sales 數值乘以1.5
SELECT STORE_ID, STORE_NAME, SALES,
	CASE STORE_NAME
		WHEN 'Los Angeles' THEN SALES * 2
        WHEN 'San Diego' THEN SALES * 1.5
        ELSE SALES
     END "NEW_SALES"
FROM STORE_INFORMATION
ORDER BY STORE_NAME, SALES;


-- 1.營業額的數字區間個數統計
-- CASE 沒有接欄位，只有條件式
-- 0 ~ 1000 = 3筆
-- 1001 ~ 2000 = 3筆
-- 2001 ~ 3000 = 3筆
-- > 3001 = 0筆
SELECT STORE_ID, STORE_NAME, SALES,
	CASE WHEN (SALES BETWEEN 0 AND 1000) THEN '0-1000'
		 WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001-2000'
         WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001-3000'
         WHEN (SALES > 3000) THEN '> 3000'
	END "SALES_RANGE"
FROM STORE_INFORMATION
ORDER BY SALES;


-- 0-1000 3
-- 1001-2000 3
-- 2001-3000 3
SELECT SALES_RANGE, COUNT(SALES_RANGE) "RANGE_COUNT"
FROM (
	SELECT 
		CASE WHEN (SALES BETWEEN 0 AND 1000) THEN '0-1000'
			 WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001-2000'
			 WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001-3000'
			 WHEN (SALES > 3000) THEN '> 3000'
		END "SALES_RANGE"
	FROM STORE_INFORMATION
	ORDER BY SALES
) STORE_RANGE
GROUP BY SALES_RANGE
ORDER BY SALES_RANGE;


-- 排名:自已與自已所有資料列逐一比較
-- 自我連結 (SELF JOIN)
SELECT S1.STORE_ID, S1.STORE_NAME, S1.SALES,
	S2.STORE_ID, S2.STORE_NAME, S2.SALES
FROM STORE_INFORMATION S1, STORE_INFORMATION S2
WHERE S2.SALES >= S1.SALES
ORDER BY S1.SALES, S2.SALES;

-- 最後一名是第九名
SELECT S1.STORE_ID, S1.STORE_NAME, S1.SALES
FROM STORE_INFORMATION S1
ORDER BY S1.SALES DESC;

-- 將結果依序列出，然後算出每一行之前(包含那一行本身)有多少行數
SELECT S1.STORE_ID, S1.STORE_NAME, S1.SALES,
	COUNT(S2.STORE_ID)
FROM STORE_INFORMATION S1, STORE_INFORMATION S2
WHERE S2.SALES >= S1.SALES
GROUP BY S1.STORE_ID, S1.STORE_NAME
ORDER BY S1.SALES DESC;

-- 1,1,3,4,5,6,7,8,9
SELECT STORE_ID, STORE_NAME, SALES,
	RANK() OVER (ORDER BY SALES DESC) "RANK_SALES"
FROM STORE_INFORMATION;

-- 區域分區排名
-- "資料劃分"排名
SELECT STORE_ID, STORE_NAME, SALES,	GEOGRAPHY_ID
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES;

SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	RANK() OVER (PARTITION BY GEOGRAPHY_ID ORDER BY SALES DESC) "RANK_SALES"
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES DESC;

-- DENSE_RANK:名次連續排名
SELECT STORE_ID, STORE_NAME, SALES,
	DENSE_RANK() OVER (ORDER BY SALES DESC) "DENSE_RANK_SALES"
FROM STORE_INFORMATION;

-- PERCENT_RANK (  )：名次所佔的百分比
-- 公式：(RANK(  ) - 1)  /  (總資料列筆數 - 1)
SELECT STORE_ID, STORE_NAME, SALES,
	PERCENT_RANK() OVER (ORDER BY SALES DESC) "PERCENT_RANK_SALES"
FROM STORE_INFORMATION;


-- ROW_NUMBER():依序編號
SELECT STORE_ID, STORE_NAME, SALES,
	ROW_NUMBER() OVER (ORDER BY SALES DESC) "ROW_NUMBER_SALES"
FROM STORE_INFORMATION;


-- 分區比較，每一筆與分區最高營業額之差距?
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) "GEOGRAPHY_MAX_SALES"
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES DESC;

SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	(MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) - SALES) "DIFF_GEOGRAPHY_MAX_SALES"
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES DESC;



SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
    -- 依「區域劃分」取營業額"最小值"
    MIN(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MIN_SALES,
    -- 依「區域劃分」取營業額"最大值"
    MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MAX_SALES,
    -- 依「區域劃分」取商店"數量"
    COUNT(STORE_ID) OVER (PARTITION BY GEOGRAPHY_ID) COUNT_STORE_ID,
    -- 依「區域劃分」取營業額"總和"
    SUM(SALES) OVER (PARTITION BY GEOGRAPHY_ID) SUM_SALES,
    -- 依「區域劃分」取營業額"平均"
    AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID) AVG_SALES
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES;


SELECT STORE_ID, STORE_NAME,
    ROW_NUMBER( ) OVER (ORDER BY SALES) ROWNO_STORE,
    SALES,
    -- 依「營業額」排序取"上一個"營業額
    LAG(SALES) OVER (ORDER BY SALES) PREV_SALES,
    -- 依「營業額」排序取"下一個"營業額
    LEAD(SALES) OVER (ORDER BY SALES) NEXT_SALES
FROM STORE_INFORMATION
ORDER BY SALES;

-- 查詢中位數
SELECT SALES "MedianSales"
FROM (
	SELECT STORE_ID, STORE_NAME, SALES,
		RANK() OVER (ORDER BY SALES DESC) "RANK_SALES"
	FROM STORE_INFORMATION
) S 
WHERE S.RANK_SALES = (
	SELECT CEIL(COUNT(STORE_ID)/2) FROM STORE_INFORMATION
);

-- 數字捨入涵數
SELECT
-- 1.CEIL(x)：返回大於或等於x的最大整數值(無條件進位)
CEIL(123.111),
-- 2.FLOOR(x)：返回小於或等於x的最小整數值(無條件捨去)
FLOOR(123.999),
-- 3.ROUND(x , [y])：
-- 返回(四捨五入)到小數點右邊y位的x值,y預設值為0
-- 如果y是"負數"，則捨入到小數點左邊相應的整數位上
ROUND(123.15, 1), 
ROUND(123.14, 1),
ROUND(123.5, -1),
ROUND(125.5, -1);

-- 字符函數
-- 1.LOWER(string) :返回小寫形式的string,不是字母的不受影響.
-- 2.UPPER(string)：返回大寫形式的string
SELECT LOWER('APPLE'), UPPER('apple');
SELECT LOWER(STORE_NAME) FROM STORE_INFORMATION;
SELECT STORE_NAME FROM STORE_INFORMATION
WHERE LOWER(STORE_NAME) = 'boston';

-- 日期函數
-- MySQL轉換函數：
-- 1.DATE_FORMAT(date,format):日期轉字串
SELECT DATE_FORMAT(SYSDATE(), '%Y/%m/%d %T'),
-- 2.STR_TO_DATE(str,format):字串轉日期
STR_TO_DATE('2021-08-15 00:00:00', "%Y-%m-%d %T"),
DATE_ADD(STR_TO_DATE('2021-08-15 00:00:00', "%Y-%m-%d %T"), INTERVAL 5 DAY);


-- MS SQL
-- 1.日期轉字串
SELECT convert(varchar, getdate(), 100) 'mon dd yyyy hh:mmAM (or PM)';
SELECT convert(varchar, getdate(), 101) 'mm/dd/yyyy';
SELECT convert(varchar, getdate(), 102) 'yyyy.mm.dd';
SELECT convert(varchar, getdate(), 103) 'dd/mm/yyyy';
SELECT convert(varchar, getdate(), 104) 'dd.mm.yyyy';
SELECT convert(varchar, getdate(), 105) 'dd-mm-yyyy';
SELECT convert(varchar, getdate(), 106) 'dd mon yyyy';
SELECT convert(varchar, getdate(), 107) 'mon dd, yyyy';
SELECT convert(varchar, getdate(), 108) 'hh:mm:ss';
SELECT convert(varchar, getdate(), 109) 'mon dd yyyy hh:mm:ss:mmmAM (or PM)';
SELECT convert(varchar, getdate(), 110) 'mm-dd-yyyy';
SELECT convert(varchar, getdate(), 111) 'yyyy/mm/dd';
SELECT convert(varchar, getdate(), 112) 'yyyymmdd';
SELECT convert(varchar, getdate(), 113) 'dd mon yyyy hh:mm:ss:mmm';
SELECT convert(varchar, getdate(), 114) 'hh:mm:ss:mmm(24h)';
SELECT convert(varchar, getdate(), 120) 'yyyy-mm-dd hh:mm:ss(24h)';
SELECT convert(varchar, getdate(), 121) 'yyyy-mm-dd hh:mm:ss.mmm';
SELECT convert(varchar, getdate(), 126) 'yyyy-mm-ddThh:mm:ss.mmm';

-- 2.字串轉日期
SELECT convert(datetime, '2021-08-16 21:52:22', 120)　'yyyy-mm-dd hh:mm:ss(24h)';

-- 取得部份日期資料
-- MySQL
SELECT SYSDATE(), YEAR(SYSDATE()), MONTH(SYSDATE()), DAY(SYSDATE()),
HOUR(SYSDATE()), MINUTE(SYSDATE()), SECOND(SYSDATE());



SELECT * FROM STORE_INFORMATION
WHERE YEAR(STORE_DATE) = 2018 AND MONTH(STORE_DATE) = 03
ORDER BY STORE_DATE;

-- MS SQL
SELECT GETDATE(), YEAR(GETDATE()), MONTH(GETDATE()), DAY(GETDATE());
SELECT GETDATE() 'Today',
DATEPART(year,GETDATE()) 'Year Part',
DATEPART(month,GETDATE()) 'Month Part',
DATEPART(day,GETDATE()) 'Day Part',
DATEPART(hour,GETDATE()) 'Hour Part',
DATEPART(minute,GETDATE()) 'Minute Part',
DATEPART(second,GETDATE()) 'Second Part',
DATEPART(millisecond,GETDATE()) 'MilliSecond Part';


-- 日期算術(MySQL):
--  MySQL日期算術:
SELECT SYSDATE(), 
DATE_ADD('2021-08-15', INTERVAL 1 DAY),
DATE_ADD('2021-08-15', INTERVAL 1 HOUR),
DATE_ADD('2021-08-15', INTERVAL 1 MINUTE);

SELECT DATE_SUB('2021-08-15', INTERVAL 5 DAY);


-- MS SQL
SELECT GETDATE(),
DATEADD(YEAR, 1, GETDATE()) "DATEADD_YEAR",
DATEADD(MONTH, 1, GETDATE()) "DATEADD_MONTH",
DATEADD(DAY, 1, GETDATE()) "DATEADD_DAY",
DATEADD(HOUR, 1, GETDATE()) "DATEADD_HOUR",
DATEADD(MINUTE, 1, GETDATE()) "DATEADD_MINUTE",
DATEADD(SECOND, 1, GETDATE()) "DATEADD_SECOND";

SELECT GETDATE(),
DATEADD(YEAR, -1, GETDATE()) "DATESUB_YEAR";

-- Oracle 日期加減(單位:天)
SELECT SYSDATE - 60 FROM DUAL;

-- Oracle DECODE
-- 	類似相同於CASE…WHEN…THEN…ELSE…END 功能
SELECT STORE_ID, STORE_NAME, SALES,
  DECODE(STORE_NAME,
    'Los Angeles', SALES * 2,
    'San Diego', SALES * 1.5,
    SALES
  ) "NEW_SALES"
FROM STORE_INFORMATION
ORDER BY STORE_NAME, SALES;


-- Oracle LEFT JOIN
SELECT G.GEOGRAPHY_ID, G.REGION_NAME, S.*
FROM GEOGRAPHY G, STORE_INFORMATION S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID(+);

-- Oracle RIGHT JOIN
SELECT G.GEOGRAPHY_ID, G.REGION_NAME, S.*
FROM GEOGRAPHY G, STORE_INFORMATION S
WHERE G.GEOGRAPHY_ID(+) = S.GEOGRAPHY_ID;


